#!/usr/bin/env python3

# Copyright 2017 Juan Luis Álvarez Martínez
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
# http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Convert the dataset CSV files into usable C headers.

import sys

USAGE = '''\
Usage: csv-to-header.py VAR_NAME INPUT_FILE OUTPUT_HEADER \
'''

HEADER_BOILERPLATE = '''/*
 ------------------------------------------
 --- Autogenerated file, do not modify! ---
 ------------------------------------------
*/
'''

# ------------
# --- Main ---
# ------------
if __name__ == '__main__':
  if len(sys.argv) != 4:
    print(USAGE)
    exit()
  
  var_name = sys.argv[1]
  in_path = sys.argv[2]
  out_path = sys.argv[3]
  
  in_text = ''
  
  with open(in_path, 'rb') as f:
    in_text = str(f.read(), 'utf-8')
    f.close()
  
  #convert \r\n to \n
  in_text = in_text.replace('\r\n', '\n')
  
  #Split by line
  in_lines = in_text.split('\n')
  
  #process lines
  out_lines = []
  for line in in_lines:
    if line.startswith('#'):
      #Line is a comment
      out_lines.append("  /* %s */" % line[1:])
    elif len(line) == 0:
      pass
    else:
      #Lines are numbers
      #Trim trailing comma, add leading 0x
      line = '  0x' + line[:-1]
      
      #Replace all commas with ', 0x'
      line = line.replace(',', ', 0x')
      
      #Re-add the trailing comma
      out_lines.append(line + ',')
      
  #Write out header, lines, tail
  with open(out_path, 'wb') as f:
    f.write(bytes(HEADER_BOILERPLATE, 'utf-8'))
    f.write( bytes('#ifndef __' + var_name.upper() + '\n', 'utf-8') )
    f.write( bytes('#define __' + var_name.upper() + '\n', 'utf-8') )
    f.write( bytes('#include <stdint.h>' + '\n', 'utf-8') )
    f.write( bytes('static const uint16_t ' + var_name + '[] = {' + '\n', 'utf-8') )
    
    for line in out_lines:
      f.write(bytes(line + '\n', 'utf-8'))
      
    f.write( bytes('};\n', 'utf-8') )
    f.write( bytes('#endif\n', 'utf-8') )
    f.close()
    